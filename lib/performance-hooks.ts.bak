import { useMemo, useCallback } from 'react';
import type { DependencyList } from 'react';

// === HOOK PARA MEMOIZACIÓN OPTIMIZADA ===

/**
 * Hook para memoización de objetos complejos
 * Evita re-renderizados innecesarios cuando las dependencias no cambian
 */
export const useDeepMemo = <T>(
  factory: () => T,
  deps: DependencyList
): T => {
  return useMemo(factory, deps);
};

/**
 * Hook para memoización de callbacks con dependencias específicas
 */
export const useOptimizedCallback = <T extends (...args: any[]) => any>(
  callback: T,
  deps: DependencyList
): T => {
  return useCallback(callback, deps);
};

// === UTILIDADES DE MEMOIZACIÓN ===

/**
 * Memoiza un array de objetos basado en sus IDs
 */
export const memoizeArrayById = <T extends { id: string }>(
  array: T[]
): T[] => {
  return useMemo(() => {
    const map = new Map<string, T>();
    array.forEach(item => map.set(item.id, item));
    return Array.from(map.values());
  }, [array]);
};

/**
 * Memoiza resultados de filtrado para arrays grandes
 */
export const useMemoizedFilter = <T>(
  array: T[],
  filterFn: (item: T) => boolean,
  deps: DependencyList = []
): T[] => {
  return useMemo(() => {
    return array.filter(filterFn);
  }, [array, ...deps]);
};

/**
 * Memoiza cálculos complejos con cache
 */
export const useMemoizedCalculation = <T, R>(
  data: T,
  calculation: (data: T) => R,
  deps: DependencyList = []
): R => {
  return useMemo(() => {
    return calculation(data);
  }, [data, ...deps]);
};

// === COMPONENTES MEMOIZADOS ===

import React, { memo } from 'react';

/**
 * HOC para memoización de componentes con comparación personalizada
 */
export const withMemo = <P extends object>(
  Component: React.ComponentType<P>,
  propsAreEqual?: (prevProps: P, nextProps: P) => boolean
) => {
  return memo(Component, propsAreEqual);
};

/**
 * Comparador personalizado para props con arrays
 */
export const arrayPropsComparator = <P extends Record<string, any>>(
  prevProps: P,
  nextProps: P
): boolean => {
  const keys = Object.keys(prevProps) as (keyof P)[];
  
  return keys.every(key => {
    const prevValue = prevProps[key];
    const nextValue = nextProps[key];
    
    // Si son arrays, comparar por longitud y elementos
    if (Array.isArray(prevValue) && Array.isArray(nextValue)) {
      if (prevValue.length !== nextValue.length) return false;
      return prevValue.every((item, index) => 
        item === nextValue[index] || 
        (typeof item === 'object' && item?.id === nextValue[index]?.id)
      );
    }
    
    // Comparación normal para otros tipos
    return prevValue === nextValue;
  });
};

// === DEBOUNCE Y THROTTLE ===

import { useRef, useEffect } from 'react';

/**
 * Hook para debounce de valores
 */
export const useDebounce = <T>(value: T, delay: number): T => {
  const [debouncedValue, setDebouncedValue] = React.useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
};

/**
 * Hook para throttle de funciones
 */
export const useThrottle = <T extends (...args: any[]) => any>(
  callback: T,
  delay: number
): T => {
  const lastCall = useRef<number>(0);
  const timeoutRef = useRef<NodeJS.Timeout>();

  return useCallback((...args: Parameters<T>) => {
    const now = Date.now();
    
    if (now - lastCall.current >= delay) {
      lastCall.current = now;
      return callback(...args);
    } else {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = setTimeout(() => {
        lastCall.current = Date.now();
        callback(...args);
      }, delay - (now - lastCall.current));
    }
  }, [callback, delay]) as T;
};

// === CACHE EN MEMORIA ===

interface CacheEntry<T> {
  data: T;
  timestamp: number;
  ttl: number;
}

class MemoryCache {
  private cache = new Map<string, CacheEntry<any>>();

  set<T>(key: string, data: T, ttl: number = 5 * 60 * 1000): void {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl
    });
  }

  get<T>(key: string): T | null {
    const entry = this.cache.get(key);
    
    if (!entry) return null;
    
    const isExpired = Date.now() - entry.timestamp > entry.ttl;
    
    if (isExpired) {
      this.cache.delete(key);
      return null;
    }
    
    return entry.data;
  }

  clear(): void {
    this.cache.clear();
  }

  size(): number {
    return this.cache.size;
  }
}

export const memoryCache = new MemoryCache();

/**
 * Hook para cache con TTL
 */
export const useCachedData = <T>(
  key: string,
  fetcher: () => Promise<T>,
  ttl: number = 5 * 60 * 1000,
  deps: DependencyList = []
): { data: T | null; loading: boolean; error: Error | null } => {
  const [data, setData] = React.useState<T | null>(null);
  const [loading, setLoading] = React.useState(false);
  const [error, setError] = React.useState<Error | null>(null);

  useEffect(() => {
    const cachedData = memoryCache.get<T>(key);
    
    if (cachedData) {
      setData(cachedData);
      return;
    }

    setLoading(true);
    setError(null);

    fetcher()
      .then(result => {
        setData(result);
        memoryCache.set(key, result, ttl);
      })
      .catch(err => {
        setError(err instanceof Error ? err : new Error('Unknown error'));
      })
      .finally(() => {
        setLoading(false);
      });
  }, [key, ttl, ...deps]);

  return { data, loading, error };
};

// === OPTIMIZACIÓN DE IMÁGENES ===

export const useImagePreload = (imageSources: string[]): boolean => {
  const [loaded, setLoaded] = React.useState(false);

  useEffect(() => {
    let loadedCount = 0;
    const totalImages = imageSources.length;

    if (totalImages === 0) {
      setLoaded(true);
      return;
    }

    imageSources.forEach(src => {
      const img = new Image();
      img.onload = () => {
        loadedCount++;
        if (loadedCount === totalImages) {
          setLoaded(true);
        }
      };
      img.onerror = () => {
        loadedCount++;
        if (loadedCount === totalImages) {
          setLoaded(true);
        }
      };
      img.src = src;
    });
  }, [imageSources]);

  return loaded;
};

// === VIRTUALIZACION SIMPLE ===

interface VirtualListProps<T> {
  items: T[];
  itemHeight: number;
  containerHeight: number;
  renderItem: (item: T, index: number) => React.ReactNode;
  overscan?: number;
}

export const VirtualList = <T,>({
  items,
  itemHeight,
  containerHeight,
  renderItem,
  overscan = 5
}: VirtualListProps<T>) => {
  const [scrollTop, setScrollTop] = React.useState(0);

  const visibleStart = Math.floor(scrollTop / itemHeight);
  const visibleEnd = Math.min(
    visibleStart + Math.ceil(containerHeight / itemHeight),
    items.length - 1
  );

  const paddingTop = visibleStart * itemHeight;
  const paddingBottom = (items.length - visibleEnd - 1) * itemHeight;

  const visibleItems = items.slice(
    Math.max(0, visibleStart - overscan),
    Math.min(items.length, visibleEnd + overscan)
  );

  return (
    <div
      style={{ height: containerHeight, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.currentTarget.scrollTop)}
    >
      <div style={{ height: paddingTop }} />
      {visibleItems.map((item, index) => (
        <div key={visibleStart + index} style={{ height: itemHeight }}>
          {renderItem(item, visibleStart + index)}
        </div>
      ))}
      <div style={{ height: paddingBottom }} />
    </div>
  );
};